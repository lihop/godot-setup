"use strict";

require("core-js/modules/es.object.define-property.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

require("regenerator-runtime/runtime.js");

require("core-js/modules/es.object.to-string.js");

require("core-js/modules/es.promise.js");

require("core-js/modules/es.array.concat.js");

require("core-js/modules/es.array.map.js");

require("core-js/modules/es.function.name.js");

require("core-js/modules/es.function.bind.js");

require("core-js/modules/es.array.join.js");

require("core-js/modules/es.regexp.exec.js");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.string.iterator.js");

require("core-js/modules/web.dom-collections.iterator.js");

var _os = _interopRequireDefault(require("os"));

var _fs = _interopRequireDefault(require("fs"));

var _path = _interopRequireDefault(require("path"));

var _extractZip = _interopRequireDefault(require("extract-zip"));

var _getReleases = _interopRequireDefault(require("./getReleases"));

var _getLatest = _interopRequireDefault(require("./getLatest"));

var _download = _interopRequireDefault(require("./download"));

var _rpad = _interopRequireDefault(require("./rpad"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function pass() {
  return true;
}

var MultiProgress = require('multi-progress');

function downloadRelease(_x, _x2, _x3) {
  return _downloadRelease.apply(this, arguments);
}

function _downloadRelease() {
  _downloadRelease = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(user, repo, _outputDir) {
    var filterRelease,
        filterAsset,
        leaveZipped,
        disableLogging,
        bars,
        releases,
        release,
        promises,
        _args2 = arguments;
    return regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            filterRelease = _args2.length > 3 && _args2[3] !== undefined ? _args2[3] : pass;
            filterAsset = _args2.length > 4 && _args2[4] !== undefined ? _args2[4] : pass;
            leaveZipped = _args2.length > 5 && _args2[5] !== undefined ? _args2[5] : false;
            disableLogging = _args2.length > 6 && _args2[6] !== undefined ? _args2[6] : false;
            bars = new MultiProgress(process.stderr);
            _context2.next = 7;
            return (0, _getReleases["default"])(user, repo);

          case 7:
            releases = _context2.sent;
            release = (0, _getLatest["default"])(releases, filterRelease, filterAsset);

            if (release) {
              _context2.next = 11;
              break;
            }

            throw new Error("Could not find a release for ".concat(user, "/").concat(repo, " (").concat(_os["default"].platform(), " ").concat(_os["default"].arch(), ")"));

          case 11:
            if (!disableLogging) {
              console.error("Downloading ".concat(user, "/").concat(repo, "@").concat(release.tag_name, "..."));
            }

            promises = release.assets.map( /*#__PURE__*/function () {
              var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(asset) {
                var progress, bar, outputDir, destf, dest;
                return regeneratorRuntime.wrap(function _callee$(_context) {
                  while (1) {
                    switch (_context.prev = _context.next) {
                      case 0:
                        if (process.stdout.isTTY && !disableLogging) {
                          bar = bars.newBar("".concat((0, _rpad["default"])(asset.name, 24), " :bar :etas"), {
                            complete: 'â–‡',
                            incomplete: '-',
                            width: process.stdout.columns - 36,
                            total: 100
                          });
                          progress = bar.update.bind(bar);
                        }

                        outputDir = _path["default"].isAbsolute(_outputDir) ? _outputDir : _path["default"].resolve(_outputDir);

                        if (!_fs["default"].existsSync(outputDir)) {
                          _fs["default"].mkdirSync(outputDir);
                        }

                        if (_fs["default"].statSync(outputDir).isDirectory()) {
                          _context.next = 5;
                          break;
                        }

                        throw new Error("Output path \"".concat(outputDir, "\" must be a directory"));

                      case 5:
                        destf = _path["default"].join(outputDir, asset.name);

                        if (_fs["default"].existsSync(destf)) {
                          _context.next = 14;
                          break;
                        }

                        dest = _fs["default"].createWriteStream(destf);
                        _context.next = 10;
                        return (0, _download["default"])(asset.url, dest, progress);

                      case 10:
                        if (!(!leaveZipped && /\.zip$/.exec(destf))) {
                          _context.next = 14;
                          break;
                        }

                        _context.next = 13;
                        return (0, _extractZip["default"])(destf, {
                          dir: outputDir
                        });

                      case 13:
                        _fs["default"].unlinkSync(destf);

                      case 14:
                        return _context.abrupt("return", destf);

                      case 15:
                      case "end":
                        return _context.stop();
                    }
                  }
                }, _callee);
              }));

              return function (_x4) {
                return _ref.apply(this, arguments);
              };
            }());
            return _context2.abrupt("return", Promise.all(promises));

          case 14:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _downloadRelease.apply(this, arguments);
}

var _default = downloadRelease;
exports["default"] = _default;