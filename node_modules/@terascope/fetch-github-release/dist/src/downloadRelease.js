"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.downloadRelease = void 0;
const os_1 = __importDefault(require("os"));
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const extract_zip_1 = __importDefault(require("extract-zip"));
const getReleases_1 = require("./getReleases");
const getLatest_1 = require("./getLatest");
const download_1 = require("./download");
const rpad_1 = require("./rpad");
function pass() {
    return true;
}
const MultiProgress = require('multi-progress');
/**
 * Download a specific github release
 * @param user The name of the github user or organization
 * @param repo The name of the github repository
 * @param outputDir The directory to write the release to
 * @param filterRelease Optionally filter the release
 * @param filterAsset Optionally filter the asset for a given release
 * @param leaveZipped Optionally leave the file zipped
 * @param leaveZipped Optionally disable logging for quiet output
*/
async function downloadRelease(user, repo, outputDir, filterRelease = pass, filterAsset = pass, leaveZipped = false, disableLogging = false) {
    if (!user) {
        throw new Error('Missing user argument');
    }
    if (!repo) {
        throw new Error('Missing user argument');
    }
    const bars = new MultiProgress(process.stderr);
    const releases = await (0, getReleases_1.getReleases)(user, repo);
    const release = (0, getLatest_1.getLatest)(releases, filterRelease, filterAsset);
    if (!release) {
        throw new Error(`Could not find a release for ${user}/${repo} (${os_1.default.platform()} ${os_1.default.arch()})`);
    }
    if (!disableLogging) {
        console.error(`Downloading ${user}/${repo}@${release.tag_name}...`);
    }
    const promises = release.assets.map(async (asset) => {
        let progress;
        if (process.stdout.isTTY && !disableLogging) {
            const bar = bars.newBar(`${(0, rpad_1.rpad)(asset.name, 24)} :bar :etas`, {
                complete: 'â–‡',
                incomplete: '-',
                width: process.stdout.columns - 36,
                total: 100
            });
            progress = bar.update.bind(bar);
        }
        // eslint-disable-next-line no-param-reassign
        outputDir = path_1.default.isAbsolute(outputDir) ? outputDir : path_1.default.resolve(outputDir);
        if (!fs_1.default.existsSync(outputDir)) {
            fs_1.default.mkdirSync(outputDir);
        }
        if (!fs_1.default.statSync(outputDir).isDirectory()) {
            throw new Error(`Output path "${outputDir}" must be a directory`);
        }
        const destf = path_1.default.join(outputDir, asset.name);
        if (!fs_1.default.existsSync(destf)) {
            const dest = fs_1.default.createWriteStream(destf);
            await (0, download_1.download)(asset.url, dest, progress);
            if (!leaveZipped && /\.zip$/.exec(destf)) {
                await (0, extract_zip_1.default)(destf, {
                    dir: outputDir
                });
                fs_1.default.unlinkSync(destf);
            }
        }
        return destf;
    });
    return Promise.all(promises);
}
exports.downloadRelease = downloadRelease;
//# sourceMappingURL=downloadRelease.js.map